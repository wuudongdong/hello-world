# 面试题
## 1. 事务的隔离级别分别解决什么问题？怎么实现的？
事务的隔离级别分为四层：读未提交、读已提交、可重复读、串行化。读未提交未解决任何事务并发问题，读已提交解决脏读（一个事务未提交的数据能被别的事务看到）
的问题，可重复读解决不可重复读（一个事务中在不同时间点的相同的查询所出现的结果不同）的问题，串行化解决幻读（一个事务中多次条件查询的结果不一致）
的问题。oracle的默认的事务隔离级别是读已提交，mysql默认的事务隔离级别是可重复读。
读已提交和可重复读在mysql中是靠MVCC多版本并发控制来实现的，每条数据都有一个隐藏列是事务id代表这条数据的版本，而事务id是一个单调递增的序列，这样
每个事务都只能拿到比自己版本号小的数据。

## 2. 事务四大特性是什么？
ACID，A是原子性，一组操作要么全部成功，要么全部失败。C是一致性，数据库跨表、跨行、始终保持在一致性的状态。I是隔离性，事务之间互不影响。D是持久性，
事务完成后，数据持久化保存。

## 3. MySQL有哪些存储引擎，它们的区别和适用场景是什么？
MySQL默认使用的是InnoDB，支持事务、外键、行级锁，除它之外的所有存储引擎都不支持事务。Myisam不支持事务和外键，只有表锁。它适用于只有插入和查询的
表，处理速度比InnoDB快，它的的索引是非聚集索引，索引文件和数据文件分开存放，寻找直接比InnoDB快，不用维护MVCC，占用的空间也小。Memory的数据存储
在内存中，数据不可持久化，适用于做临时表，Archive归档引擎，支持数据压缩，适用于指查询和插入的数据，如日志信息。

## 4. MySQL索引有哪些类型？索引的数据结构有哪些？这些数据结构的适用场景？
MySQL索引分为两种主键索引和非主键索引，主键索引又可以称作聚簇索引，非主键索引又可称作二级索引。聚簇索引的意思是叶子节点的主键和数据行是存放在一起的，
二级索引的叶子节点则只有主键。索引的数据模型有三种，分别是哈希表、有序数组、搜索树。哈希表适合用于定值搜索。有序数组适用于静态数据搜索。搜索树时间复
杂度是O（log（N）），适合磁盘访问特性，磁盘随机读取一个数据块的时间大概在10ms左右，N叉树可以减少磁盘IO次数，故MySQL适用B+树作为索引的数据结构。
为了减少页分裂和页合并，尽量使用自增主键。

## 5. B树和B+树的区别是什么？
B树和B+树的区别主要有两点：一是B+树的中间节点不存放数据，二是B+树的叶子节点间有链指针。根据磁盘预读和局部性原理，中间节点不存放数据，那么一次能读
取到节点数量更多，节点之间有指针，区间访问性更好，对于索引范围查找，性能更高。

参考资料：https://www.jianshu.com/p/0371c9569736

## 6. 联合索引的生效条件是什么？
联合索引的索引项中包含多个字段，分别从左到右排列。索引的最左前缀原则指的是索引生效的条件是查询条件中用到最左边的N个字段或者第一个字段的M个字符。索引
下推优化指的是在通过联合索引的其他字段判断减少回表次数。

参考资料：https://time.geekbang.org/column/article/69636

## 7. MySQL的锁有哪些类型？分别用来做什么？
MySQL的锁有分为全局锁、表级锁、行锁。
- 全局锁
  使用Flush tables with read lock命令来使用，用来锁整个数据库，数据备份时使用。如果数据库中所有的表都使用的是InnoDB存储引擎，那么可以使
用一致性视图来对数据库加锁。
- 表级锁  
  1. MDL
    MDL也分为读锁和写锁，读锁在我们对表做增删改查时，数库会默认给我们加上，写锁是当我们改表结构时，MySQL会默认加写锁。读写锁是冲突的，当我们持有
  MDL读锁，也就是我们在查表的一条数据时，是不能改表结构的，只有读锁释放，加上写锁才能改表结构。
  2. 表锁
    表锁的语法是lock tables x read/write。lock tables t1 read, t2 write;表示只能对t1读，对t2读写，别的表也不能访问。
- 行锁
  行锁没有特定的语法，当事务并发更新同一条数据时，数据库会帮我们加锁。两阶段锁协议是指行锁需要时才加上，等事务提交以后才释放。共享锁的语法：share 
  in model；排他锁的语法：for update。行锁锁的是索引记录。间隙锁锁的是范围。

参考资料：https://learnku.com/articles/39212

## 8. 有过SQL性能优化的经验吗？
SQL性能优化可以从插入优化、更新优化、查询优化这三个方面来讲。
- 插入优化
  我们可以使用预编译的PraperStatement，可以使用多值插入和add batch，对于大数据量的数据导入，可以使用数据库自带的工具，同时在数据导入前，去除索
  引和约束。
- 更新优化
  当我们在对数据做更新和删除的时候，尽量选择确定的主键。避免使用非主键的范围查询条件，有可能产生间隙锁。
- 查询优化
  1. 模糊查询
    模糊查询时要考虑索引的最左前缀原则，索引失效的情况。
  2. 连接查询
    要注意驱动表的选择问题，避免笛卡尔积，有些表连接的sql完全可以用子查询来替换。选择小表做驱动表，小表的含义是通过查询条件过滤出来的字段数据量小
     的表，意思就是不仅要考虑数据行数还有字段的多少。当我们使用join时，不仅要注意使用小表做驱动表，还要注意需要在连接字段上建立索引，避免使用BNL
     算法，尽量使用BLJ、BKA算法。
  3. 索引失效
    Null，Not，Not in，函数等都不会走索引，减少使用or，可以用并集来替换。大数据量下，有es替代。
  4. 业务侧SQL重新设计
    查询数据量和查询次数的平衡，避免不必要的数据传输，分析类的需求，可以使用汇总表。

参考资料：https://time.geekbang.org/column/article/80147

## 9. 数据库调优思路有哪些？
存储引擎、字段类型、索引、sql优化、读写分离、分区表、分库分表。存储引擎一般没什么特殊的需求都选择InnoDB，如果是有些冷数据，没有接口调用，但是还是
得保存的可以使用存档引擎，可以压缩数据。数据库的字段类型分为3类，数字、字符串、时间。一个原则就是在合适的情况下，尽量选择占用字节小的字段类型。比如
用tinyint代替字符串，用timestamp代替datetime。能用自增主键的尽量用，字符串类型的主键一般来说占用空间比较大，而且由于它的无序性，可能导致页分裂
和页合并的问题。索引不是越多越好，一个表的索引最多不要超过6个，索引增多会影响插入和删除的性能。选择那些选择性高的列添加索引，合理地建联合索引，注意
最左前缀原则。读写分离可以在业务层自己实现，也可以用中间件来实现，如何解决过期读的问题呢？可以根据具体的业务场景，如果数据不允许过期，那么就去主库读，
如果业务允许还是可以走从库。

## 9. explain的时候最关心哪些字段，分别是什么含义?
explain主要关心type和rows字段，type表示join type，const表示最多只有一个匹配行，ref会走索引，但走索引匹配的不是主键或者唯一索引，range是索引
范围查找，向like，>,>=,<,<=,between,in 都走范围查找，all 全表扫描。

## 10. 一条 SQL 语句是如何执行的？
MySQL 的系统架构分为 Server 层和存储引擎层，一条简单的 SQL，会经过 MySQL 的 Server 层的连接器、缓存器、分析器、优化器、执行器，最后调用存储
引擎的接口返回数据。连接器负责与客户端建立 TCP 连接，校验权限；缓存器用来缓存查询的数据，以 key-value 形式保存数据，当有对表的更新操作时，会清除
所有这个表缓存的数据，所以默认这个缓存是不开启的，在 MySQL 8.0 以后，缓存器已经被彻底删除掉了；分析器主要用来做词法分析和语法分析，词法分析用来决
定具体是什么语句，select、insert、update、delete 以及查的是那张表，where 后面哪些列对应的什么字段，语法分析用来校验 SQL 是否有语法问题；优化
器用来决定具体使用那个索引以及关联表的执行计划；执行器具体调用引擎的接口返回数据。

## 11. 数据量比较大的 group by 语句如何优化？



## 12. 分库分表以后表关联怎么做？


## 13. 说说你对分布式事务的理解？

