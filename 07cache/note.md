# 面试题
## 1. 如何解决缓存和数据库数据不一致的情况？
首先应该明白数据一致性的概念，一致性包含两种情况：一是缓存中有数据，那么缓存的数据应该跟数据库中数据相同；二是缓存中没数据，那么数据库中的数据应该是
最新的数据。
- 读写缓存<br>
1、同步写回策略
2、异步写回策略
- 只读缓存<br>
1、先删缓存后删数据库<br>
  延迟双删：更新数据库的线程删除完缓存后，更新数据库的值，暂停一段时间，然后再次删除缓存值。<br>
2、先删数据库后删缓存<br>
  中间件重试机制<br>
- 最佳实践<br>
  多数情况下，会使用只读缓存，并且使用先删除数据库后删除缓存的策略，有两个原因，一是先删缓存会由于缓存缺失给数据库带来压力；二是延迟双删的时间不好
测算。

参考资料：https://time.geekbang.org/column/article/295812 

## 2. 缓存雪崩、缓存击穿、缓存穿透分别是什么？怎么解决这些问题？
缓存雪崩、缓存击穿、缓存穿透表示的是由于三种不同的原因导致的数据库请求压力激增的现象。
- 缓存雪崩
缓存雪崩的原因有两个，一个是多个key同时失效，二是缓存实例宕机。
- 缓存雪崩的解决方案
应对多个key同时失效，可以采用在key的失效时间上加随机数、服务熔断、降级等方式；应对实例宕机可以采用主从集群的方式
- 缓存击穿
缓存击穿是由于热点key的缺失导致的，解决方案是不设置热点key的超时时间
- 缓存穿透
缓存穿透的原因是缓存和数据库中都没有数据 
- 缓存穿透的解决方案
1、缓存空值或者错误值
2、布隆过滤器
3、前端请求校验，拦截非法请求
  
参考资料：https://time.geekbang.org/column/article/296586

## 3. 布隆过滤器的原理是什么？怎么提高准确性？
布隆过滤器的三个重要的点是初始值全为0的byte数组、三个哈希函数、取模，布隆过滤器有三个hash函数，对一个值分别进行三次hash运算得到三个不同的值，
再对数组长度取模将该位置置位1，判断值是否在数据库中时，对值进行三次hash运算后取模，如果有为0的，说明值不存在。布隆过滤器说元素不存在那就一定不存在，
布隆过滤器有误判率，假设误判率是0.03，意思是如果我们通过布隆过滤器运算得出元素存在，那么意思是有97%的概率存在。<br>
参考资料：https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md

## 4. 如何用Redis和zk实现分布式锁？
使用Redis来实现分布式锁需要注意三点：一是要使用setnx，就是当值不存在的时候再设置，二是锁要加过期时间，三是锁的值要唯一，避免解锁的时候解错锁，
解锁的时候要保证原子性。实际使用时要考虑重试。<br>
使用zk实现的分布式锁的原理是使用了临时顺序节点的特性，临时节点是客户端连接断开的话会自动删除的节点，加锁的时候创建临时顺序节点，如果创建的临时顺序
节点的顺序最小，表示加锁成功，否则订阅前一个临时顺序节点的删除事件，等待，然后再次尝试加锁，加锁成功后，处理业务，处理完业务之后删除临时节点。<br>
参考资料：https://time.geekbang.org/column/article/301092
https://blog.csdn.net/qq_35190492/article/details/105352672

## 5. 可以谈谈Redis的数据类型以及各种数据类型的实现原理吗？
Redis的基础数据类型有5种，分别是String、List、Hash、Sorted Set、Set。这5种基本数据类型的底层的数据结构：String类型在redis中是使用简单动态
字符串SDS来实现的，List是用压缩列表和双向链表来实现的，Hash是用压缩列表和哈希表来实现的，Sorted Set是用压缩列表和跳表来实现的，Set是用整数数组
和哈希表来实现的。此外Redis还有三种扩展数据类型，分别是Bitmap、HyperLogLog、GEO,Bitmap和HyperLogLog都是用来做统计的，不同的是Bitmap用来做
二值统计，像统计一亿用户连续10天登录的用户数这种场景，而HyperLogLog则适用于做基数统计，像统计网站UV的这种场景，两个的共同点是都非常节省内存。GEO
这种数据类型主要用在位置信息服务中，它可以实现类似"附近搜索"等功能，它底层使用的是Sorted Set来实现的，将经纬度信息通过GeoHash编码转换成对应区间
的编码用作权重，来实现范围搜索。
- 简单动态字符串<br>
Redis的string数据类型底层使用的是SDS简单动态字符串,SDS结构包含三个部分组成,free:表示未被分配的字节数,用4个字节表示, alloc: 表示分配给该字符
串的字节数,其总是2的幂次方,占四个字节, buff: 用来存储数据的字节数组,具体大小由实际数据决定,redis之所以采用2的幂次方来分配内存是为了减少分配内存
的次数所带来的开销,一个SDS结构除去数据存储的数据外,有8个字节的额外开销用来描述数据,此外redis的数据不论是key还是value都使用一个RedisObjec来表
示,它有一些原数据(例如 lru 最后一次访问的数据戳, 引用计数,用来进行垃圾回收) 占8个字节,还有指向实际数据的指针占8字节,这里要说的是,Redis的string
有3种编码方式int、ebmstr、raw,这三种编码方式的转换方式如下: 当使用string来保存的数据是64位无符号的整数的时候使用int编码,用redisObject的指针
部分来保存数据,当保存的不是整数而是小于等于44个字节的字符串时,使用embstr编码方式来保存字符串,这个方式的redisObject和sds数据保存在一块儿连续的
内存上,是为了减少内存碎片,当字符串的长度大于44时,使用raw编码方式,这种方式的redisObject结构和实际数据不是在连续的内存上的,通过指针来关联。<br>

参考资料：https://time.geekbang.org/column/article/279649

## 6. Redis数据持久化的方式有哪些呢？ 这些持久化方式的区别在哪里呢？
Redis有两种持久化的方式RDB和AOF。
- AOF<br>
AOF的持久化的方式是将对Redis的指令记录到文件中来实现的，具体的策略有三种，分别是Always（同步写回，可靠性最高，对性能影响最大）、
EverySecend（每秒写回）、No（由操作系统决定何时写回，性能最高，可靠性最差），这种持久化方式的弊端：1、受文件系统的限制，不能存储大文件。2、文件
越大，写入的耗时越长。3、故障恢复的时间也越长。通常aof文件的大小是固定大小的，也就是说如果文件大小到达某个阈值会出发bgrewriteaof子线程，它要做的
事就是减小aof文件的大小，那么怎么减小呢？就是拷贝最新的全量数据，从头开始将指令记录到文件中，生成新文件替换老文件。这个过程可以"用一处拷贝，两处日
志"来描述，一处拷贝是指拷贝主线程的内存页表，两处日志是指在日志重写的过程中，如果有新的请求对数据有更改，会将指令分别记录在日志缓存和日志重写缓存中，
等到日志重写完成，会将缓存中的指令写入新日志中。<br>
参考资料：https://time.geekbang.org/column/article/271754
- RDB<br>
RDB持久化的方式是做内存快照，它的策略是可配置的，默认的配置是900 1，300 10， 60 10000，根据key变更的频率缩减做内存快照的频率，尽可能保证内存快
照里是最新的数据，由于内存快照保存的是二进制文件，所以这种持久化方式的文件小，故障恢复或者重启的时候消耗的时间相比AOF的方式小，所以Redis的主从初次
同步采用的方式是RDB文件，但是可靠性没有AOF高，可能存在数据丢失的可能。Redis在做内存快照的时候也在像AOF一样fork出bgsave主进程，那么此时如果在内
存快照的期间，有数据变更怎么办？Redis采用的是操作系统的写时复制，当数据变更是他会新申请一块内存来保存变更后的数据，并且修改主线程的内存页表，那么
就可以保证bgsave子进程拿到的数据不会发生改变。<br>  
参考资料：https://time.geekbang.org/column/article/271839

## 7. 为什么单线程的 Redis 能那么快？
Redis的单线程指的是Redis处理网络IO和数据读写是在一个线程中的，这个线程也是Redis的主线程。那么为什么Redis不使用多线程呢？其实是为了避免多线程带
来的并发控制问题。Redis的性能有多高呢？单节点读写的吞吐量大概在十几万的QPS，为什么能达到这个水平的呢？首先Redis的数据都是存在内存中的，访问速度
肯定比磁盘IO要快一个数量级，其次Redis采用了高效的数据结构，它的全局哈希表，时间复杂度都是O（1）的，其次Redis采用多路复用的IO模型避免在一个客户端
上阻塞。<br>
参考资料：https://time.geekbang.org/column/article/270474

## 8. Redis 的主从复制是如何实现的？
Redis的主从复制是采用首次全量RDB加基于长连接的增量指令来实现的。那么主从是如何保证数据一致性的呢？在主从第一次传输RDB的过程中，主节点会将在此期间
的写命令写入replication buffer中，待文件传输完成后，将相应的指令基于长连接发送给从节点，如果主从的网络断开连接，主节点会记录各从节点的指令到
repl backlog buffer中去，它是一个环形缓冲区，等从节点连接上主节点的时候，再发送给从节点偏移量以后的指令。
参考资料：https://time.geekbang.org/column/article/272852

## 9. Redis 的数据淘汰策略有几种？
Redis4.0以后有8种数据淘汰策略，默认的配置是不进行数据淘汰的 noeviction，剩余的7种按照是否有过期时间分成两种，其中它们共有的策略有random、lru、
lfu，有过期时间的还多一种策略是ttl，按照过期时间的先后淘汰。推荐如果不存在热点数据的话，使用allkeys-lru，如果有那就使用volatile-lru，最大内存
推荐设置全数据量的15%～30%。