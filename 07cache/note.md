# 面试题
## 1. 如何解决缓存和数据库数据不一致的情况？
首先应该明白数据一致性的概念，一致性包含两种情况：一是缓存中有数据，那么缓存的数据应该跟数据库中数据相同；二是缓存中没数据，那么数据库中的数据应该是最新的数据。
- 读写缓存<br>
1、同步写回策略
2、异步写回策略
- 只读缓存<br>
1、先删缓存后删数据库<br>
  延迟双删：更新数据库的线程删除完缓存后，更新数据库的值，暂停一段时间，然后再次删除缓存值。<br>
2、先删数据库后删缓存<br>
  中间件重试机制<br>
- 最佳实践<br>
  多数情况下，会使用只读缓存，并且使用先删除数据库后删除缓存的策略，有两个原因，一是先删缓存会由于缓存缺失给数据库带来压力；二是延迟双删的时间不好测算

参考资料：https://time.geekbang.org/column/article/295812 

## 2. 缓存雪崩、缓存击穿、缓存穿透分别是什么？怎么解决这些问题？
缓存雪崩、缓存击穿、缓存穿透表示的是由于三种不同的原因导致的数据库请求压力激增的现象。
- 缓存雪崩
缓存雪崩的原因有两个，一个是多个key同时失效，二是缓存实例宕机。
- 缓存雪崩的解决方案
应对多个key同时失效，可以采用在key的失效时间上加随机数、服务熔断、降级等方式；应对实例宕机可以采用主从集群的方式
- 缓存击穿
缓存击穿是由于热点key的缺失导致的，解决方案是不设置热点key的超时时间
- 缓存穿透
缓存穿透的原因是缓存和数据库中都没有数据 
- 缓存穿透的解决方案
1、缓存空值或者错误值
2、布隆过滤器
3、前端请求校验，拦截非法请求<br>

参考资料：https://time.geekbang.org/column/article/296586

## 3. 布隆过滤器的原理是什么？怎么提高准确性？
布隆过滤器的三个重要的点是初始值全为0的byte数组、三个哈希函数、取模，布隆过滤器有三个hash函数，对一个值分别进行三次hash运算得到三个不同的值，
再对数组长度取模将该位置置位1，判断值是否在数据库中时，对值进行三次hash运算后取模，如果有为0的，说明值不存在。布隆过滤器说元素不存在那就一定不存在，
布隆过滤器有误判率，假设误判率是0.03，意思是如果我们通过布隆过滤器运算得出元素存在，那么意思是有97%的概率存在。

参考资料：https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md

## 4. 如何用Redis和zk实现分布式锁？
使用Redis来实现分布式锁需要注意三点：一是要使用setnx，就是当值不存在的时候再设置，二是锁要加过期时间，三是锁的值要唯一，避免解锁的时候解错锁，
解锁的时候要保证原子性。实际使用时要考虑重试。<br>
使用zk实现的分布式锁的原理是使用了临时顺序节点的特性，临时节点是客户端连接断开的话会自动删除的节点，加锁的时候创建临时顺序节点，如果创建的临时顺序
节点的顺序最小，表示加锁成功，否则订阅前一个临时顺序节点的删除事件，等待，然后再次尝试加锁，加锁成功后，处理业务，处理完业务之后删除临时节点。<br>

参考资料：https://time.geekbang.org/column/article/301092
https://blog.csdn.net/qq_35190492/article/details/105352672

## 5. 可以谈谈Redis的数据类型以及各种数据类型的实现原理吗？
Redis的基础数据类型有5种，分别是String、List、Hash、Sorted Set、Set。这5种基本数据类型的底层的数据结构：String类型在redis中是使用简单动态字符串SDS
来实现的，List是用压缩列表和双向链表来实现的，Hash是用压缩列表和哈希表来实现的，Sorted Set是用压缩列表和跳表来实现的，Set是用整数数组和哈希表来实现的。此外
Redis还有三种扩展数据类型，分别是Bitmap、HyperLogLog、GEO,Bitmap和HyperLogLog都是用来做统计的，不同的是Bitmap用来做二值统计，像统计一亿用户连续10天
登录的用户数这种场景，而HyperLogLog则适用于做基数统计，像统计网站UV的这种场景，两个的共同点是都非常节省内存。GEO这种数据类型主要用在位置信息服务中，它可以
实现类似"附近搜索"等功能，它底层使用的是Sorted Set来实现的，将经纬度信息通过GeoHash编码转换成对应区间的编码用作权重，来实现范围搜索。
- 简单动态字符串
Redis的string数据类型底层使用的是SDS简单动态字符串,SDS结构包含三个部分组成,free:表示未被分配的字节数,用4个字节表示, alloc: 表示分配给该字符串的字节数,
其总是2的幂次方,占四个字节, buff: 用来存储数据的字节数组,具体大小由实际数据决定,redis之所以采用2的幂次方来分配内存是为了减少分配内存的次数所带来的开销,
一个SDS结构除去数据存储的数据外,有8个字节的额外开销用来描述数据,此外redis的数据不论是key还是value都使用一个RedisObjec来表示,它有一些原数据
(例如 lru 最后一次访问的数据戳, 引用计数,用来进行垃圾回收) 占8个字节,还有指向实际数据的指针占8字节,这里要说的是,Redis的string有3种编码方式
int、ebmstr、raw,这三种编码方式的转换方式如下: 当使用string来保存的数据是64位无符号的整数的时候使用int编码,用redisObject的指针部分来保存数据,
当保存的不是整数而是小于等于44个字节的字符串时,使用embstr编码方式来保存字符串,这个方式的redisObject和sds数据保存在一块儿连续的内存上,是为了减少内存碎片,
当字符串的长度大于44时,使用raw编码方式,这种方式的redisObject结构和实际数据不是在连续的内存上的,通过指针来关联
  
参考资料：https://time.geekbang.org/column/article/279649
